# RTC02 - DS3231闹钟功能示例

## 📋 案例目的

本案例的主要目的是：

- **核心目标**：演示如何使用DS3231实时时钟模块的双闹钟功能（Alarm1和Alarm2）
- **学习重点**：
  - 理解DS3231双闹钟配置流程
  - 掌握DS3231闹钟设置方法（`DS3231_SetAlarm1()`和`DS3231_SetAlarm2()`）
  - 掌握DS3231闹钟读取方法（`DS3231_ReadAlarm1()`和`DS3231_ReadAlarm2()`）
  - 掌握DS3231闹钟标志检测方法（`DS3231_CheckAlarm1Flag()`和`DS3231_CheckAlarm2Flag()`）
  - 学习闹钟触发后的处理流程
  - 学习GPIO按键检测方法
  - 学习闹钟显示格式处理（不同匹配模式的日期计算）
- **应用场景**：适用于需要定时提醒、闹钟功能的应用，如定时器、提醒器、闹钟等

## 🔧 硬件要求

### 必需外设

- **LED1**：`PA1`（闹钟触发指示）

### 传感器/模块

- **DS3231实时时钟模块**（I2C接口）
  - SCL：`PB10`（软件I2C）
  - SDA：`PB11`（软件I2C）
  - VCC：3.3V
  - GND：GND
  - **上拉电阻**：SCL和SDA需要4.7kΩ-10kΩ上拉到3.3V（I2C总线必需）
  - **注意**：本案例不使用INT/SQW引脚，通过轮询状态寄存器检测闹钟触发

- **OLED显示屏**（SSD1306，软件I2C接口）
  - SCL：`PB8`（软件I2C）
  - SDA：`PB9`（软件I2C）
  - VCC：3.3V
  - GND：GND

- **按键**（用于清除闹钟标志）
  - 信号线：`PA0`（GPIO输入，下拉）
  - 另一端：连接到3.3V（按下时高电平）

**⚠️ 重要提示**：

1. **I2C上拉电阻必须添加**：DS3231的SCL和SDA线必须添加上拉电阻（4.7kΩ-10kΩ）到3.3V，否则I2C通信会失败
2. **引脚不冲突**：DS3231（PB10/11）和OLED（PB8/9）使用不同的I2C实例，不会冲突
3. **按键连接**：按键一端接PA0，另一端接3.3V，按下时PA0为高电平
4. **INT/SQW引脚**：本案例不使用INT/SQW引脚，通过软件轮询检测闹钟触发

## 📦 模块依赖

- `soft_i2c`：软件I2C驱动模块（DS3231和OLED使用软件I2C）
- `ds3231`：DS3231实时时钟驱动模块（核心）
- `gpio`：GPIO驱动模块（软件I2C依赖、按键输入）
- `led`：LED驱动模块（闹钟触发指示）
- `oled`：OLED显示模块（显示时间和闹钟信息）
- `delay`：延时模块
- `TIM2_TimeBase`：TIM2时间基准模块（延时模块依赖）
- `system_init`：系统初始化模块

## 🔄 实现流程

### 整体逻辑

本案例演示DS3231双闹钟功能的完整流程，整体流程如下：

1. **初始化阶段**
   - 系统初始化（时钟、GPIO等）
   - LED和OLED初始化
   - 软件I2C2初始化（用于DS3231）
   - DS3231初始化
   - 检查并清除OSF标志（如果存在）
   - 启动DS3231振荡器
   - 清除闹钟标志（防止启动时误触发）
   - GPIO按键初始化（PA0，下拉输入）

2. **第一次读取闹钟值**
   - 读取DS3231中已设置的Alarm1和Alarm2值（旧的）
   - 显示第一次读取的闹钟值

3. **设置新闹钟**
   - 读取当前时间
   - 计算Alarm1时间：当前时间+5分钟（日期时分秒匹配模式）
   - 计算Alarm2时间：当前时间+10分钟（星期时分秒匹配模式）
   - 写入Alarm1和Alarm2到DS3231

4. **第二次读取闹钟值**
   - 读取刚写入的Alarm1和Alarm2值（新的）
   - 显示第二次读取的闹钟值

5. **使能闹钟**
   - 清除闹钟标志（确保干净状态）
   - 使能Alarm1和Alarm2
   - 设置DS3231中断模式为闹钟中断
   - LED1开机闪烁3次

6. **主循环**
   - 每秒读取并显示当前时间
   - 显示两个闹钟的设置值
   - **检测DS3231硬件闹钟标志（Alarm1或Alarm2）**
   - 闹钟触发时：LED1常亮，显示"Alarm Triggered!"
   - 检测按键按下，清除闹钟标志并关闭LED1

### 关键方法

- **双闹钟配置**：同时使用Alarm1和Alarm2，可以设置不同的触发时间
- **闹钟匹配模式**：
  - Alarm1使用日期时分秒匹配模式（`DS3231_ALARM_MODE_DAY_HOUR_MIN_SEC_MATCH`）
  - Alarm2使用星期时分秒匹配模式（`DS3231_ALARM_MODE_WEEKDAY_HOUR_MIN_SEC_MATCH`）
- **时间计算**：基于当前时间计算闹钟时间（+5分钟和+10分钟），自动处理时间溢出
- **硬件触发**：由DS3231硬件闹钟标志控制触发，通过轮询状态寄存器检测
- **LED指示**：LED1开机闪烁3次，之后只有闹钟触发时才常亮
- **按键清除**：检测到按键按下后，清除两个闹钟标志并关闭LED1

### 工作流程示意

```text
系统初始化
    ↓
LED和OLED初始化
    ↓
软件I2C2初始化（PB10/11）
    ↓
DS3231初始化
    ↓
检查并清除OSF标志
    ↓
启动DS3231振荡器
    ↓
清除闹钟标志（防止误触发）
    ↓
GPIO按键初始化（PA0）
    ↓
第一次读取闹钟值（旧的）
    ↓
显示第一次读取的闹钟值
    ↓
读取当前时间
    ↓
计算并设置新闹钟（当前时间+5分钟和+10分钟）
    ↓
第二次读取闹钟值（新的）
    ↓
显示第二次读取的闹钟值
    ↓
清除闹钟标志并使能闹钟
    ↓
LED1开机闪烁3次
    ↓
主循环：
    - 每秒读取并显示时间
    - 显示两个闹钟值
    - 检测DS3231硬件闹钟标志
    - 闹钟触发 → LED1常亮，显示提示
    - 按键按下 → 清除标志，关闭LED1
```

## 📚 关键函数说明

### DS3231相关函数

- **`DS3231_Init()`**：初始化DS3231模块
  - 在本案例中用于配置DS3231接口类型和I2C实例
  - 必须在使用其他DS3231函数前调用

- **`DS3231_CheckOSF()`**：检查OSF（振荡器停止标志）
  - 在本案例中用于检测DS3231是否曾经断电或振荡器停止
  - OSF标志被设置时，时间可能不准确，需要重新设置时间

- **`DS3231_ClearOSF()`**：清除OSF标志
  - 在本案例中用于清除OSF标志，确保时间状态正常

- **`DS3231_Start()`**：启动DS3231振荡器
  - 在本案例中用于确保DS3231振荡器运行
  - 必须在设置时间前启动振荡器

- **`DS3231_ReadAlarm1()`**：读取闹钟1设置
  - 在本案例中用于读取DS3231中已设置的Alarm1值
  - 第一次读取：读取旧的闹钟值
  - 第二次读取：读取新设置的闹钟值

- **`DS3231_ReadAlarm2()`**：读取闹钟2设置
  - 在本案例中用于读取DS3231中已设置的Alarm2值
  - 第一次读取：读取旧的闹钟值
  - 第二次读取：读取新设置的闹钟值

- **`DS3231_SetAlarm1()`**：设置闹钟1
  - 在本案例中用于配置闹钟1（日期时分秒匹配模式，当前时间+5分钟）
  - 需要设置闹钟结构体（模式、秒、分、时、日/星期）
  - 本案例使用日期时分秒匹配模式，匹配日期、时、分、秒字段

- **`DS3231_SetAlarm2()`**：设置闹钟2
  - 在本案例中用于配置闹钟2（星期时分秒匹配模式，当前时间+10分钟）
  - 需要设置闹钟结构体（模式、秒、分、时、星期）
  - 本案例使用星期时分秒匹配模式，匹配星期、时、分、秒字段
  - Alarm2没有秒字段，秒固定为0

- **`DS3231_EnableAlarm1()`**：使能闹钟1中断
  - 在本案例中用于使能闹钟1中断
  - 使能后，闹钟触发时DS3231会设置闹钟标志

- **`DS3231_EnableAlarm2()`**：使能闹钟2中断
  - 在本案例中用于使能闹钟2中断
  - 使能后，闹钟触发时DS3231会设置闹钟标志

- **`DS3231_SetInterruptMode()`**：设置DS3231中断模式
  - 在本案例中用于设置DS3231为闹钟中断模式（`DS3231_INT_MODE_ALARM`）
  - 必须设置为闹钟中断模式，否则闹钟触发时不会设置标志

- **`DS3231_CheckAlarm1Flag()`**：检查闹钟1标志
  - 在本案例中用于检测Alarm1是否触发
  - 返回1表示闹钟已触发，0表示未触发

- **`DS3231_CheckAlarm2Flag()`**：检查闹钟2标志
  - 在本案例中用于检测Alarm2是否触发
  - 返回1表示闹钟已触发，0表示未触发

- **`DS3231_ClearAlarm1Flag()`**：清除闹钟1标志
  - 在本案例中用于清除Alarm1标志
  - 在启动时清除，防止误触发
  - 在按键按下时清除，关闭闹钟

- **`DS3231_ClearAlarm2Flag()`**：清除闹钟2标志
  - 在本案例中用于清除Alarm2标志
  - 在启动时清除，防止误触发
  - 在按键按下时清除，关闭闹钟

- **`DS3231_ReadTime()`**：读取DS3231当前时间
  - 在本案例中用于读取并显示当前时间
  - 用于计算新闹钟时间（当前时间+5分钟和+10分钟）
  - 用于显示闹钟的完整日期（不同匹配模式的日期计算）

### GPIO相关函数

- **`GPIO_Config()`**：配置GPIO引脚
  - 在本案例中用于配置PA0为下拉输入模式
  - 按键按下时，PA0读取为高电平

- **`GPIO_ReadPin()`**：读取GPIO引脚电平
  - 在本案例中用于检测按键是否按下
  - 返回`Bit_SET`表示按键按下（高电平）

### LED相关函数

- **`LED_Init()`**：初始化LED模块
  - 在本案例中用于初始化LED1（PA1）

- **`LED_On()`**：打开LED
  - 在本案例中用于闹钟触发时打开LED1

- **`LED_Off()`**：关闭LED
  - 在本案例中用于关闭LED1（开机闪烁后和按键清除后）

### OLED相关函数

- **`OLED_Init()`**：初始化OLED显示模块
  - 在本案例中用于初始化OLED显示屏
  - 必须在使用其他OLED函数前调用

- **`OLED_Clear()`**：清空OLED显示
  - 在本案例中用于清空屏幕，准备显示新内容

- **`OLED_ShowString()`**：显示字符串
  - 在本案例中用于显示提示信息、时间和闹钟值

- **`OLED_ShowChar()`**：显示单个字符
  - 在本案例中用于清除行尾残留字符

**详细函数实现和调用示例请参考**：`main_example.c` 中的代码

## 🔗 相关文档

- [DS3231驱动模块文档](../../Drivers/sensors/ds3231.h)
- [软件I2C驱动模块文档](../../Drivers/i2c/i2c_sw.h)
- [OLED驱动模块文档](../../Drivers/display/oled_ssd1306.h)
- [GPIO驱动模块文档](../../Drivers/basic/gpio.h)
- [LED驱动模块文档](../../Drivers/basic/led.h)
- [主程序代码](main_example.c)
- [硬件配置](board.h)
- [模块配置](config.h)

## ⚠️ 注意事项与重点

### ⚠️ 重要提示

1. **I2C上拉电阻必须添加**
   - DS3231的SCL和SDA线必须添加上拉电阻（4.7kΩ-10kΩ）到3.3V
   - 否则I2C通信会失败，无法读取或写入时间

2. **OSF标志处理**
   - 如果DS3231曾经断电，OSF标志会被设置
   - 必须清除OSF标志后再使用，否则时间可能不准确
   - 写入新时间后会自动清除OSF标志

3. **闹钟匹配模式选择**
   - Alarm1使用日期时分秒匹配模式（`DS3231_ALARM_MODE_DAY_HOUR_MIN_SEC_MATCH`）
   - Alarm2使用星期时分秒匹配模式（`DS3231_ALARM_MODE_WEEKDAY_HOUR_MIN_SEC_MATCH`）
   - 可以根据需要选择其他匹配模式（秒匹配、分秒匹配、时分秒匹配等）

4. **闹钟标志清除**
   - 闹钟触发后，标志会被设置
   - 必须清除标志后，闹钟才能再次触发
   - 本案例在启动时清除标志（防止误触发），在按键按下时清除标志（关闭闹钟）

5. **时间计算和溢出处理**
   - 基于当前时间计算闹钟时间（+5分钟和+10分钟）
   - 自动处理分钟溢出（超过59分钟）
   - 自动处理小时溢出（超过23小时）
   - 日期溢出处理简化（假设每月最多31天）

### 🔑 关键点

1. **双闹钟配置流程**
   - 先读取旧的闹钟值（第一次读取）
   - 设置新的闹钟时间和匹配模式（Alarm1和Alarm2）
   - 读取新设置的闹钟值（第二次读取）
   - 清除闹钟标志（防止误触发）
   - 使能两个闹钟中断
   - 最后设置DS3231中断模式为闹钟中断
   - 必须按顺序执行，否则闹钟无法正常工作

2. **闹钟匹配模式理解**
   - 秒匹配模式：只匹配秒字段，其他字段不匹配
   - 分秒匹配模式：匹配分和秒字段
   - 时分秒匹配模式：匹配时、分、秒字段
   - 日期时分秒匹配模式：匹配日期、时、分、秒字段（Alarm1使用）
   - 星期时分秒匹配模式：匹配星期、时、分、秒字段（Alarm2使用）

3. **闹钟显示格式**
   - 根据闹钟匹配模式计算完整的日期时间
   - 日期匹配模式：直接使用闹钟中的日期值
   - 星期匹配模式：计算下一个目标星期几的日期
   - 显示格式：`YY/M/D HH:MM:SS`（紧凑格式）

4. **LED指示逻辑**
   - LED1开机闪烁3次（表示系统启动）
   - 之后LED1保持关闭
   - 只有闹钟触发时LED1才常亮
   - 按键清除闹钟后LED1关闭

5. **按键检测**
   - 使用下拉输入模式，按键按下时为高电平
   - 检测到按键按下后，清除两个闹钟标志并关闭LED1
   - 需要添加消抖处理（本案例使用简单检测）
   - 实际应用中建议使用中断或硬件消抖

## 🔍 扩展练习

1. **修改闹钟触发时间**：修改代码中的闹钟设置，尝试不同的触发时间（如每小时的第0分0秒）
2. **改变匹配模式**：尝试使用秒匹配、分秒匹配、时分秒匹配等不同的匹配模式
3. **添加蜂鸣器功能**：添加PWM驱动蜂鸣器，闹钟触发时发出声音提示
4. **添加按键消抖**：实现硬件或软件消抖，提高按键检测的可靠性
5. **实现闹钟设置界面**：通过按键和OLED实现交互式闹钟设置功能
6. **添加闹钟状态显示**：在OLED上显示闹钟是否已设置、下次触发时间等信息
7. **使用INT/SQW引脚**：连接DS3231的INT/SQW引脚到MCU的外部中断（EXTI），实现硬件中断方式检测闹钟触发

## 📚 相关模块

- **DS3231驱动**：`Drivers/sensors/ds3231.c/h`
- **软件I2C驱动**：`Drivers/i2c/i2c_sw.c/h`
- **OLED驱动**：`Drivers/display/oled_ssd1306.c/h`
- **GPIO驱动**：`Drivers/basic/gpio.c/h`
- **LED驱动**：`Drivers/basic/led.c/h`
- **延时功能**：`system/delay.c/h`
- **系统初始化**：`system/system_init.c/h`
- **硬件配置**：案例目录下的 `board.h`



### DS3231两个闹钟同时工作的技术要点：

1. **独立寄存器**：Alarm 1和Alarm 2有完全独立的时、分、秒/日期寄存器（0x07-0x0D），可同时设置不同触发时间。
2. **共享中断**：两个闹钟共享同一个INT/SQW引脚输出，但：
   - 状态寄存器(0x0F)的A1F和A2F位分别指示哪个闹钟触发
   - 控制寄存器(0x0E)的A1IE和A2IE位分别控制各自使能
3. **触发逻辑**：
   - 若同时触发，中断引脚会拉低，读取状态寄存器可判断是A1、A2或两者同时触发
   - 需手动写0清除状态位以撤销中断
4. **工作模式**：支持多种组合，如Alarm 1每天响一次+Alarm 2每周一响一次，互不干扰。

**简单说**：两个闹钟完全独立，可以一起用，但要注意中断共享和状态清除。

---

**最后更新**：2024-01-01

